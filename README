Description

This library is a modified version of Raphael GrafÎéÎ÷s ActionScript Expression Parser. When I wrote the JavaScript Function Plotter, I wanted a better alternative to using JavaScriptÎéÎ÷s eval function. ThereÎéÎ÷s no security risk currently, because you can only run code in your own browser, but itÎéÎ÷s not as convenient for math (Math.pow(2^x) instead of 2^x, etc.).

Download

Get the code from github.

Documentation (incomplete, of course)

Parser

Parser is the main class in the library. It has ÎéÎístaticÎéÎí methods for parsing and evaluating expressions.

Parser()
Constructor. In most cases, you donÎéÎ÷t need this. Eventually, IÎéÎ÷ll get around to documenting why you would want to, but for now, you can figure it out by reading the source ;-).
parse({expression: string})
Convert a mathematical expression into an Expression object.
evaluate({expression: string} [, {variables: object}])
Parse and immediately evaluate an expression using the values/functions from the {variables} object.
Parser.evaluate(expr, vars) is equivalent to calling Parser.parse(expr).evaluate(vars). In fact, thatÎéÎ÷s exactly what it does.

Parser.Expression

Parser.parse returns an Expression object. Expression objects are similar to JavaScript functions, i.e. they can be ÎéÎícalledÎéÎí with variables bound to passed-in values. In fact, they can even be converted into JavaScript functions.

evaluate([{variables: object}])
Evaluate an expression, with variables bound to the values in {variables}. Each unbound variable in the expression is bound to the corresponding member of the {variables} object. If there are unbound variables, evaluate will throw an exception.
js> expr = Parser.parse("2 ^ x");
(2^x)
js> expr.evaluate({ x: 3 });
8
substitute({variable: string}, {expr: Expression, string, or number})
Create a new expression with the specified variable replaced with another expression (essentially, function composition).
js> expr = Parser.parse("2 * x + 1");
((2*x)+1)
js> expr.substitute("x", "4 * x");
((2*(4*x))+1)
js> expr2.evaluate({ x: 3});
25
simplify({variables: object>)
Simplify constant sub-expressions and replace variable references with literal values. This is basically a partial evaluation, that does as much of the calcuation as it can with the provided variables. Function calls are not evaluated (except the built-in operator functions), since they may not be deterministic.
Simplify is pretty simple (see what I did there?). It doesnÎéÎ÷t know that addition and multiplication are associative, so ÎéÎí((2*(4*x))+1)ÎéÎí from the previous example cannot be simplified unless you provide a value for x. ÎéÎí2*4*x + 1ÎõÎé can however, because itÎéÎ÷s parsed as ÎéÎí(((2*4)*x)+1)ÎéÎí, so the ÎéÎí(2*4)ÎéÎí sub-expression will be replaced with ÎéÎí8ÎõÎé, resulting in ÎéÎí((8*x)+1)ÎéÎí.

js> expr = Parser.parse("x * (y * atan(1))").simplify({ y: 4 });
(x*3.141592653589793)
js> expr.evaluate({ x: 2 });
6.283185307179586
variables()
Get an array of the unbound variables in the expression.
js> expr = Parser.parse("x * (y * atan(1))");
(x*(y*atan(1)))
js> expr.variables();
x,y
js> expr.simplify({ y: 4 }).variables();
x
toString()
Convert the expression to a string. toString() surrounds every sub-expression with parentheses (except literal values, variables, and function calls), so itÎéÎ÷s useful for debugging precidence errors.
toJSFunction({parameters: Array} [, {variables: object}])
Convert an Expression object into a callable JavaScript function. You need to provide an array of parameter names that should normally be expr.variables(). Any unbound-variables will get their values from the global scope.
toJSFunction works by simplifying the Expression (with {variables}, if provided), converting it to a string, and passing the string to the Function constructor (with some of its own code to bring built-in functions and constants into scope and return the result of the expression).

Expression Syntax

The parser accepts a pretty basic grammar. Operators have the normal precidence ÎíÎñ f(x,y,z) (function calls), ^ (exponentiation), *, /, and % (multiplication, division, and remainder), and finally +, -, and || (addition, subtraction, and string concatenation) ÎíÎñ and bind from left to right (yes, even exponentiationÎíÎõ itÎéÎ÷s simpler that way).

ThereÎéÎ÷s also a ÎéÎí,ÎéÎí (comma) operator that concatenates values into an array. ItÎéÎ÷s mostly useful for passing arguments to functions, since it doesnÎéÎ÷t always behave like you would think with regards to multi-dimensional arrays. If the left value is an array, it pushes the right value onto the end of the array, otherwise, it creates a new array ÎéÎí[left, right]ÎéÎí. This makes it impossible to create an array with another array as itÎéÎ÷s first element.

Function operators

The parser has several built-in ÎéÎífunctionsÎéÎí that are actually operators. The only difference from an outside point of view, is that they cannot be called with multiple arguments and they are evaluated by the simplify method if their arguments are constant.

Function	Description
sin(x)	Sine of x (x is in radians)
cos(x)	Cosine of x (x is in radians)
tan(x)	Tangent of x (x isÎíÎõ well, you know)
asin(x)	Arc sine of x (in radians)
acos(x)	Arc cosine of x (in radians)
atan(x)	Arc tangent of x (in radians)
sqrt(x)	Square root of x. Result is NaN (Not a Number) if x is negative.
log(x)	Natural logarithm of x (not base-10). ItÎéÎ÷s log instead of ln because thatÎéÎ÷s what JavaScript calls it.
abs(x)	Absolute value (magnatude) of x
ceil(x)	Ceiling of x ÎíÎñ the smallest integer thatÎéÎ÷s >= x.
floor(x)	Floor of x ÎíÎñ the largest integer thatÎéÎ÷s <= x
round(x)	X, rounded to the nearest integer, using ÎéÎígradeschool roundingÎéÎí.
exp(x)	ex (exponential/antilogarithm function with base e)
Pre-defined functions

Besides the ÎéÎíoperatorÎéÎí functions, there are several pre-defined functions. You can provide your own, by binding variables to normal JavaScript functions. These are not evaluated by simplify.

Function	Description
random(n)	Get a random number in the range [0, n). If n is zero, or not provided, it defaults to 1.
fac(n)	n! (factorial of n: ÎéÎín * (n-1) * (n-2) * ÎíÎõ * 2 * 1ÎõÎé)
min(a,b,ÎíÎõ)	Get the smallest (ÎéÎíminimumÎéÎí) number in the list
max(a,b,ÎíÎõ)	Get the largest (ÎéÎímaximumÎéÎí) number in the list
pyt(a, b)	Pythagorean function, i.e. the c in ÎéÎíc2 = a2 + b2ÎéÎí
pow(x, y)	xy. This is exactly the same as ÎéÎíx^yÎéÎí. ItÎéÎ÷s just provided since itÎéÎ÷s in the Math object from JavaScript
atan2(y, x)	arc tangent of x/y. i.e. the angle between (0, 0) and (x, y) in radians.
